/**
 * @module main/message
 * @summary Whiteflag JS message class
 */
export { WfMessage, WfMetaHeader };
import { WfCoreMessage, WfAccount } from '@whiteflagprotocol/core';
/**
 * A Whiteflag message as defined by the Whiteflag specification
 * @class WfMessage
 * @wfversion v1-draft.7
 * @wfreference 4 Message Format
 * @remarks This class extends the core Whiteflag message class by
 * adding metadata to the message, additional data conversions (such as to and
 * from JSON), and specific Whiteflag protocol features. This allows the class
 * to be used and integrated in larger functional applications in accordance
 * with the Whiteflag specification.
 */
declare class WfMessage extends WfCoreMessage {
    /** The message metadata required for processing the message */
    protected meta: WfMetaHeader;
    /**
     * Constructor for a Whiteflag message
     * @param type the Whiteflag message type
     * @param version the Whiteflag protocol version
     */
    constructor(type: string, version?: string);
    /**
     * Creates new Whiteflag message from a JSON string
     * @function fromJSON
     * @param message a JSON string with a Whiteflag message
     * @returns a new Whiteflag message
     * @throws {WfProtocolError} if message could not be created
     */
    static fromJSON(message: string): Promise<WfMessage>;
    /**
     * Creates new Whiteflag message from a plain object
     * @function fromObject
     * @param message a plain JavaScript object with a Whiteflag message
     * @returns a new Whiteflag message object
     */
    static fromObject(message: any): Promise<WfMessage>;
    /**
     * Creates new Whiteflag message from a hexadecimal encoded string
     * @param message  atring with the hexadecimal encoded message
     * @param account the hexadecimal encoded originator address, if the message is encrypted
     * @param ikm the hexadecimalinput key material to derive the encryption key, if the message is encrypted
     * @param iv the hexadecimal initialisation vector, if required for the encryption method
     * @returns a new Whiteflag message object with the decoded message
     */
    static fromHex(message: string, account?: WfAccount, ikm?: string, iv?: string): Promise<WfMessage>;
    /**
     * Creates new Whiteflag message from a binary encoded message
     * @param message a Uint8Array with the binary encoded message
     * @param account the binary encoded originator address, if the message is encrypted
     * @param ikm the input key material to derive the encryption key, if the message is encrypted
     * @param iv the initialisation vector, if required for the encryption method
     * @returns a new Whiteflag message object with the decoded message
     */
    static fromU8a(message: Uint8Array, account?: WfAccount, ikm?: Uint8Array, iv?: Uint8Array): Promise<WfMessage>;
    /**
     * Returns the value of the metaheader field
     * @function getMeta
     * @param fieldName the name of the metaheader field
     * @returns the value of the metaheader field
     */
    getMeta(fieldName: string): string | null;
    /**
     * Sets the value of the specified metaheader field
     * @function setMeta
     * @param fieldName the name of the metaheader field
     * @param value the value to set
     * @return true if succesful, else false
     */
    setMeta(fieldName: string, value: string): boolean;
    /**
     * Returns the Whiteflag message as a plain object
     * @function toObject
     * @returns the message as a plain object
     */
    toObject(): Object;
    /**
     * Returns the Whiteflag message as a JSON string
     * @function toJSON
     * @returns the message as a JSON string
     */
    toJSON(): string;
}
/**
 * Defines a Whiteflag message header object
 * @interface WfMetaHeader
 */
interface WfMetaHeader {
    [key: string]: any;
    /** Indicates if the message has been
     * automatically generated */
    autoGenerated?: string;
    /** The name identifying the underlying blockchain */
    blockchain?: string;
    /** Indicates if this message is to be transmitted (TX) to the
     * blockchain or has been received (RX) from the blockchain */
    transceiveDirection?: string;
    /** Indicates if message was succesfully put into a
     * blockchain transaction */
    transmissionSuccess?: boolean;
    /** The hash of the transaction containing the Whiteflag message,
     * encoded as specified for the blockchain */
    transactionHash?: string;
    /** The timestamp of the message transaction or block
     * containing the Whiteflag message */
    transactionTime?: string;
    /** The index of the message transaction in a block */
    transactionIndex?: number;
    /** The number of the block the message transaction is in */
    blockNumber?: number;
    /** The number of blocks from current block where transaction
     * is in, * until the confirmation maximum is reached */
    blockDepth?: number;
    /** Indication whether the message is confirmed,
     * i.e. the minimal block depth has been reached */
    confirmed?: boolean;
    /** The address of the blockchain account to which
     * the message is sent (required to determine encryption key) */
    recipientAddress?: string;
    /** The address of the blockchain account from which
     * the message is sent */
    originatorAddress?: string;
    /** The public key of the blockchain account from which
     * the message is sent */
    originatorPubKey?: string;
    /** Indicates if a valid A-message preceded this message,
     * or if it is itself a valid A-message */
    originatorValid?: boolean;
    /** Indicates if this messages references other
     * messages correctly */
    referenceValid?: boolean;
    /** Indicates if the message complies with the
     * Whiteflag specification */
    formatValid?: boolean;
    /** Message validation errors */
    validationErrors?: string[];
    /** The hexadecimal representation of the message
     * in compressed binary encoding, optionally encrypted */
    encodedMessage?: string;
    /** The hexadecimal representation of the initialisation
     * vector of an encrypted message */
    encryptionInitVector?: string;
    /** The hexadecimal representation of the secret from which
     * the encryption key is derived */
    encryptionKeyInput?: string;
}
